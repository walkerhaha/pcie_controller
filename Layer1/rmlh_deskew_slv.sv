// ------------------------------------------------------------------------------
// 
// Copyright 2002 - 2020 Synopsys, INC.
// 
// This Synopsys IP and all associated documentation are proprietary to
// Synopsys, Inc. and may only be used pursuant to the terms and conditions of a
// written license agreement with Synopsys, Inc. All other use, reproduction,
// modification, or distribution of the Synopsys IP or the associated
// documentation is strictly prohibited.
// 
// Component Name   : DWC_pcie_ctl
// Component Version: 5.90a
// Release Type     : GA
// ------------------------------------------------------------------------------

// -------------------------------------------------------------------------
// ---  RCS information:
// ---    $DateTime: 2020/09/18 02:33:28 $
// ---    $Revision: #10 $
// ---    $Id: //dwh/pcie_iip/main/fairbanks/design/Layer1/rmlh_deskew_slv.sv#10 $
// -------------------------------------------------------------------------
// --- Module Description: Receive MAC layer handler Deskew Slave
// -----------------------------------------------------------------------------
// --- This module handles Deskewing for one lane
// -----------------------------------------------------------------------------

`include "include/DWC_pcie_ctl_all_defs.svh"

 
 module rmlh_deskew_slv (
// ---- inputs ---------------
    core_rst_n,
    core_clk,
    cfg_elastic_buffer_mode,
    cfg_ts2_lid_deskew,
    active_nb,
    active_nb_d,
    slv_do_deskew, // act as an active low reset to the deskew logic, generated by ltssm in certain states (ex: RCVRY_SPEED)
    smseq_ts1_rcvd_pulse, // used to detect a TS1/TS2 boundary, which is one of the conditions for deskew_enable=1
    smseq_ts2_rcvd_pulse,
    smseq_loc_ts2_rcvd, //ts2
    smseq_in_skp, //skp
    smseq_fts_skp_do_deskew, //fts->skp
    rxdata_dv,// gen12: unused, an internal copy always=1 is used instead, for gen3 it includes RxDataValid which may take 2 cycles
    rxaligned,// gen12: unused, an internal copy always=1 is used instead, for gen3 it includes RxDataValid which may take 2 cycles
    rxdata,
    rxdata_comma,// gen12: COM followed by SKP is used to validate a SKP OS, fifo is not loaded after first SKP symbol
    rxdata_skip,
    rxdata_skprm,
    rxdatak_i,
    rxerror,// Error in data indicated (8B/10B Error or Disparity Error->will be lane error status)
    current_data_rate,
    smlh_ltssm_state,
    cxl_mode_enable,
    smlh_in_rl0s,
    ltssm_lpbk_master,
    phy_type,
    unload, // pop command
    deskew_bypass,
    rpipe_eios_eieos_det,
// ---- outputs ---------------
    deskew_rxdata_dv,
    deskew_rxdata,
    deskew_rxdatak,
    deskew_rxerror,
    deskew_overflow,
    deskew_skp,
    deskew_see_idl_os,
    deskew_enable,
    deskew_ds_g12,
    deskew_skp_alignment_err
);
parameter INST          = 0;                    // The uniquifying parameter for each port logic instance.
parameter NB            = `CX_NB;               // Number of symbols (bytes) per clock cycle
parameter NBK           = `CX_NBK;              // Number of symbols (bytes) per clock cycle for datak
parameter AW            = `CX_ANB_WD;           // Width of the active number of bytes
parameter TP            = `TP;                  // Clock to Q delay (simulator insurance)

input                   core_rst_n;
input                   core_clk;
input                   cfg_elastic_buffer_mode;
input                   cfg_ts2_lid_deskew;     // do deskew at the transition from ts2 to Logic_Idle_Data transition for SRIS. It is optional
                                                // Gen4 base spec: The COM Symbol of a received SKP Ordered Set during a training sequence when NOT using SRIS
input   [AW-1:0]        active_nb;
input   [AW-1:0]        active_nb_d;
input                   slv_do_deskew;
input                   smseq_ts1_rcvd_pulse;
input                   smseq_ts2_rcvd_pulse;
input   [3:0]           smseq_loc_ts2_rcvd;
input   [3:0]           smseq_in_skp;
input                   smseq_fts_skp_do_deskew;
input                   rxdata_dv;                    // Input data is valid this cycle
input                   rxaligned;                    // Input data is valid this cycle
input   [(NB*8)-1:0]    rxdata;                       // Input data
input   [NB-1:0]        rxdata_comma;                 // Input data is comma
input   [NB-1:0]        rxdata_skip;                  // Input data is skip
input   [NB-1:0]        rxdata_skprm;                 // Input data is skip removed
input   [NBK-1:0]       rxdatak_i;                    // Input data is Kchar
input   [NB-1:0]        rxerror;                      // Error in data indicated (8B/10B Error or Disparity Error->will be lane error status)
input   [2:0]           current_data_rate;
input   [5:0]           smlh_ltssm_state;
input                   cxl_mode_enable;
input                   smlh_in_rl0s;                 // ltssm in Rx.L0s
input                   ltssm_lpbk_master;
input                   phy_type;
input                   unload;                       // unload the fifos, from rmlh_deskew all lanes' fifos are unloaded simultaneously
input                   deskew_bypass;                // deskew bypass but not deskew squelch, = 1 only for Gen1/2 rate
input                   rpipe_eios_eieos_det;         // eieos or eios detected

output                  deskew_rxdata_dv;             // Delayed data is valid (not empty)
output  [(NB*8)-1:0]    deskew_rxdata;                // Delayed data
output  [NB-1:0]        deskew_rxdatak;               // Delayed K indication
output  [NB-1:0]        deskew_rxerror;               // Delayed error indication
output                  deskew_overflow;              // We encountered overflow
output  [NB-1:0]        deskew_skp;                   // determines which lane has a SKP, used to detect alignment errors
output                  deskew_see_idl_os;
output                  deskew_enable;                // deskew takes effect
output                  deskew_ds_g12;                // gen12 data stream
output                  deskew_skp_alignment_err;

reg     [NBK-1:0]       rxdatak;
wire                    squelch;
wire                    deskew_see_idl_os;
reg                     latched_deskew_see_idl_os;
wire                    int_deskew_see_idl_os;
wire    [NB-1:0]        skip_out;
wire    [NB-1:0]        empty;
wire    [NB-1:0]        empty_fifo;
wire    [NB-1:0]        full;
wire    [NB-1:0]        almost_full; // the almost full flags are used as full when in the lower S mode
wire    [NB-1:0]        active_full;

wire    [NB-1:0]        shift_load;
wire    [NBK-1:0]       shift_rxerror;  // shifted info just prior to the fifos
wire    [NBK-1:0]       shift_rxdatak;
wire    [NBK-1:0]       shift_rxdatak_in;
wire    [NB-1:0]        shift_rxskprm;
wire    [NB-1:0]        shift_comlock;
wire    [NB*8-1:0]      shift_rxdata;
wire    [NB*8-1:0]      shift_rxdata_in; // replace shift_rxdata with SKP symbols if rxdata_skprm = 1

wire    [NB-1:0]        shift_in_load;     // shift_in_load info just prior to the muxes
wire    [NB-1:0]        shift_in_rxerror;
wire    [NB-1:0]        shift_in_rxdatak;
wire    [NB-1:0]        shift_in_rxskprm;
wire    [NB-1:0]        shift_in_comlock;
wire    [NB*8-1:0]      shift_in_rxdata;

reg     [31:0]          i_rxdata;
reg     [3:0]           i_rxdatak;
reg     [3:0]           i_rxerror;
wire    [3:0]           rx_idle_data;
wire    [3:0]           rx_data_char;
reg     [3:0]           dly_loc_ts2_rcvd;
reg     [3:0]           dly_loc_eies_rcvd;
reg     [3:0]           dly_in_skp;
wire   deskew_enable;
reg    deskew_ds_g12; //gen12 data stream
reg    deskew_enable_d;
wire   deskew_enable_rising_edge;
wire   [NB-1:0] found_lock_wire;
reg    found_lock_reg;

wire  load1;

reg      prev_com_reg;
reg      prev_skp_reg;
reg      prev_skprm_reg;
reg      prev_ts2_reg;
reg      prev_eies_reg;
wire     found_lock;
reg      slv_do_deskew_d;
wire     extra_k_sris_flag;

reg   [NB-1:0]        bit_kchar;
reg                   deskew_overflow_i;
wire                  deskew_rxdata_dv_i;
wire                  int_rxvalid;
wire  [NBK-1:0]       deskew_rxerror_i;
wire  [NBK-1:0]       deskew_rxerror_fifo;
wire  [(NB*8)-1:0]    deskew_rxdata_i;          // Delayed data
wire  [(NB*8)-1:0]    deskew_rxdata_fifo;       // Delayed data
wire  [(NB*8)-1:0]    int_rxdata;               // Delayed data
wire  [NBK-1:0]       deskew_rxdatak_i;         // Delayed K indication
wire  [NBK-1:0]       deskew_rxdatak_fifo;      // Delayed K indication
wire  [NB-1:0]        int_rxdatak;              // Delayed K indication
wire  [7:0]           masked_rxdatak;
wire  [3:0]           comk;
wire  [3:0]           idlk;
reg   [3:1]           comkq;
reg   [3:2]           idlkq;
wire  [7:1]           chk_com;
wire  [7:2]           chk_idl;

reg  [4:0] ts_state;
wire [4:0] next_ts_state;
parameter IDLE          = 0,
          TS1_RCVD      = 1,
          TS2_RCVD      = 2,
          ALIGN_ERROR   = 3,
          SUCCESS       = 4;

wire          ts2_lid_do_deskew; //ts2 -> Logic Idle Data transition
wire          eies_lid_do_deskew; //eieos -> Logic Idle Data transition
reg           latched_ts2_lid_lock_point; //ts2 -> Logic Idle Data transition
reg           latched_eies_lid_lock_point; //ts2 -> Logic Idle Data transition
reg           ts2_lid_lock_point; //ts2 -> Logic Idle Data transition
reg           eies_lid_lock_point; //eieos -> Logic Idle Data transition
wire          skp_lid_do_deskew; //SKP -> Logic Idle Data transition
reg           latched_skp_lid_lock_point; //SKP -> Logic Idle Data transition
reg           latched_fts_skp_lock_point; //FTS -> SKP transition
reg           skp_lid_lock_point; //SKP -> Logic Idle Data transition
wire          ts_do_deskew;
wire [NB-1:0] push_req_n;
wire          look_for_alignment;
reg           skp_do_deskew_reg;
reg           skp_do_deskew_r;
wire          skp_do_deskew;
wire          skp_lock_point;
wire [NB-1:0] com_lock_point;
wire          fts_skp_lock_point;
wire          fts_skp_do_deskew;

// suppress rxdatak_i for SKP-detected cycle when the SKP OS is used to enable deskew,
// e.g, rxdatak_i = {SKP, COM, k-char, k-char)
// it must be suppressed to rxdatak = {SKP, COM, 0, 0} to prevent the k-char = STP (garbage) and to cause pkt error
always @* begin : rxdatak_PROC
    rxdatak = 0;
    rxdatak = (current_data_rate == `GEN1_RATE || current_data_rate == `GEN2_RATE) & deskew_enable_rising_edge ?
 (rxdatak_i & masked_rxdatak[NBK-1:0]) : rxdatak_i;
end // rxdatak_PROC


//squelch the data and valid to pkt_finder if ~deskew_enable
//skp_do_deskew is a combinatorial logic to detect SKIP OS. And deskew_enable = skp_do_deskew | ...
//So if skp_do_deskew = 1, deskew_enable = 1 at the same cycle to not squelch data at the same cycle, too
assign squelch = ~deskew_enable /* | deskew_see_idl_os */ ;
// FIFO Read Side Logic
assign deskew_rxdata_dv   =
                            (deskew_rxdata_dv_i & !int_deskew_see_idl_os & ~squelch) | extra_k_sris_flag;
assign deskew_rxdata      = extra_k_sris_flag ? {(NB*8){1'b0}} : (current_data_rate == `GEN1_RATE || current_data_rate == `GEN2_RATE) & squelch ? 0 : deskew_rxdata_i;
assign deskew_rxdatak     = extra_k_sris_flag ? bit_kchar      : (current_data_rate == `GEN1_RATE || current_data_rate == `GEN2_RATE) & squelch ? 0 : deskew_rxdatak_i[NB-1:0];
assign deskew_rxerror     = (current_data_rate == `GEN1_RATE || current_data_rate == `GEN2_RATE) & squelch ? 0 : deskew_rxerror_i[NB-1:0];
assign deskew_overflow    = deskew_overflow_i;

   // we are ready with data when all active fifos have at least one word in them
assign deskew_rxdata_dv_i = &(
                              active_nb[1] ? ~empty[1:0] :  // 2s
                                             ~empty[0]      // 1s
                              );

// when in the the upper S mode, then use the almost_full signal
assign active_full = full;

   always @(posedge core_clk or negedge core_rst_n)
     if (~core_rst_n)
         deskew_overflow_i  <= #TP 1'b0;
     else
         deskew_overflow_i  <= #TP
                                   deskew_bypass ? 0 : |(active_full & shift_load) | ts_state[ALIGN_ERROR]; // if bypass FIFO, no overflow

assign skip_out         = {

                           (deskew_rxdatak_i[1] & (deskew_rxdata_i[15:8] == `SKIP_8B)),

                           (deskew_rxdatak_i[0] & (deskew_rxdata_i[7:0]  == `SKIP_8B))};

   // a single SKP symbol per SKP ordered set is used as alignment
   // markers on the output of the deskew block
assign deskew_skp       = skip_out;

// FIFO Write Side Logic
   wire [NB-1:0] write_rxword;
   wire [NB-1:0] write_rxword_unmask;  // this word needs to be written into a fifo, one bit per byte, based on rxdata

// the original deskew logic did not depend on rxdata_dv
// from the pipe interface, data just flowed through
//
// because of this we don't have to worry about squelch
// cases where the end of a packet isn't loaded even though
// it should be

// assign            int_rxdata_dv = rxdata_dv;
wire            int_rxdata_dv;
assign           int_rxdata_dv = cfg_elastic_buffer_mode ? rxdata_dv : 1'b1;

// Control masking of data into the FIFOs. We only write 1 SKP character per SKP ordered set
// i.e. only the SKP that immediately follows the COM. Don't push COM because a bare COM for SKP OS is converted to SKP symbol which is used to push

assign write_rxword_unmask =  {NB{int_rxdata_dv}}
                     & {

                      (|active_nb[2:1]) & ( rxdata_skprm[1] ? 1'b1 : rxdata_comma[1] ? 1'b0 : (rxdata_skprm[0] & rxdata_skip[1]) ? 1'b0 : (
                           rxdata_comma[0]
                        | ~rxdata_comma[0] & ~rxdata_skip[1]) ),

                           rxdata_skprm[0] ? 1'b1 : rxdata_comma[0] ? 1'b0 : (prev_skprm_reg & rxdata_skip[0]) ? 1'b0 : (  // COM & skprm, push; COM, no push; previous-skprm & skip, no push
                           skp_do_deskew & ~skp_do_deskew_r & prev_com_reg & ~rxdata_skip[0] ? 1'b0 :  // skp lock point and ~SKP symbol, no push
                           prev_com_reg // previous-pure-COM, push regardless
                        | ~prev_com_reg & ~rxdata_skip[0]) }; // previous-not-COM & current-not-skip, push

// signal an error if we see a SKP where the previous symbol is not a COM or a SKP
assign deskew_skp_alignment_err = ~int_rxdata_dv ? 0 :
                        (|active_nb[2:1]) & ( ~rxdata_comma[0] & ~rxdata_skip[0]  & rxdata_skip[1] & ~rxdata_skprm[1] ) |
                        ~prev_com_reg & ~prev_skp_reg & rxdata_skip[0] & ~rxdata_skprm[0];

// Identify when (and where) we are writing a SKP ordered set into the FIFOs.
// the core may have rxpolarity asserted in Polling.Active and invert SKIP symbols on some lanes. So no skip deskew lock in Polling.Active state.
assign skp_lock_point = cfg_ts2_lid_deskew ? // ts2/eieos/skp -> idle do deskew, needs SKP OS for deskew in L0/RxL0s/LoopbackMaster
                       (
                        (smlh_ltssm_state != `S_POLL_ACTIVE && (ltssm_lpbk_master || smlh_in_rl0s || smlh_ltssm_state == `S_L0 || phy_type == `PHY_TYPE_MPCIE)) & int_rxdata_dv & (
                      |{
                        |active_nb[2:1] & ( rxdata_skprm[1] ? 1'b1 :
                                           (rxdata_comma[0] & ~rxdata_skprm[0] & rxdata_skip[1]) ),
                          rxdata_skprm[0] ? 1'b1 :
                                            prev_com_reg & ~prev_skprm_reg & rxdata_skip[0]} )
                       ) :
                       (
                        (smlh_ltssm_state != `S_POLL_ACTIVE) & int_rxdata_dv & (
                      |{
                        (|active_nb[2:1]) & ( rxdata_skprm[1] ? 1'b1 :
                                           (rxdata_comma[0] & ~rxdata_skprm[0] & rxdata_skip[1]) ),
                          rxdata_skprm[0] ? 1'b1 :
                                            prev_com_reg & ~prev_skprm_reg & rxdata_skip[0]} )
                       );

// Identify when (and where) we are modifying rxdatak to k-char and modifying rxdata to zero and push into the FIFOs.
// for current symbol, if previous sym is ~COM, no modifying.
// for current symbol, if previous sym is COM but skp_removal, no modifying. (may be bare com).
// for current symbol, if it is k-char, no modifying.
// so only when current sym is ~k-char AND previous sym is (COM && ~skp_removal), modifying current rxdatak to k-char and rxdata to zero.
// the logic is used for pkt_finder to receive TLP START but no TLP END, which can cause framing error because of receiving the k-char which is not TLP END
assign com_lock_point = {                        (|active_nb[2:1]) & ( rxdata_comma[0] & ~rxdata_skprm[0] & ~rxdatak[1] ),
                         prev_com_reg & ~prev_skprm_reg & ~rxdatak[0]
                        } & {NB{int_rxdata_dv}};

// if the SKP is used to enable deskew, we must suppress the k-char bytes before {SKIP, COM, xx, xx}
assign masked_rxdatak = ~int_rxdata_dv ? 0 :
                       (|active_nb[2:1]) & (                                   rxdata_skprm[1]) ? 8'b11111110 :
                          8'b11111111;
                        

//logic below is to detect EIOS
//deskew_rxdata_dv and deskew_complete are deasserted when detecting EIOS,
//not based on detecting a single EI Symbol
assign int_rxvalid = deskew_rxdata_dv_i;
assign int_rxdata  = deskew_rxdata_i;
assign int_rxdatak = deskew_rxdatak_i[NB-1:0];

//detect COM
assign comk = {
               2'h0,
               (active_nb[2]|active_nb[1]) & int_rxvalid & int_rxdatak[1] & (int_rxdata[15:8]  == `COMMA_8B),
               |active_nb                  & int_rxvalid & int_rxdatak[0] & (int_rxdata[7:0]   == `COMMA_8B)
               };

//detect EIDLE Symbol
assign idlk = {
               2'h0,
               (active_nb[2]|active_nb[1]) & int_rxvalid & int_rxdatak[1] & (int_rxdata[15:8]  == `EIDLE_8B),
               |active_nb                  & int_rxvalid & int_rxdatak[0] & (int_rxdata[7:0]   == `EIDLE_8B)
               };

//shift COM, dependent on active_nb
always @(posedge core_clk or negedge core_rst_n) begin : comkq_PROC
    if (~core_rst_n)
        comkq <= #TP 3'h0;
    else if (active_nb[2])  // 4s
        comkq <= #TP comk[3:1];
    else if (active_nb[1])  // 2s
        comkq <= #TP {comk[1:0], comkq[3]};
    else
        comkq <= #TP {comk[0], comkq[3:2]};
end

//shift EIDLE, dependent on active_nb
always @(posedge core_clk or negedge core_rst_n) begin : idlkq_PROC
    if (~core_rst_n)
        idlkq <= #TP 2'h0;
    else if (active_nb[2])  // 4s
        idlkq <= #TP idlk[3:2];
    else if (active_nb[1])  // 2s
        idlkq <= #TP idlk[1:0];
    else
        idlkq <= #TP {idlk[0], idlkq[3]};
end

//COM and EIDLE bits location
assign chk_com = {comk[3:0], comkq[3:1]};
assign chk_idl = {idlk[3:0], idlkq[3:2]};

//2 EIDLEs to ensure eios received on buffer pop side because no COM pushed in for bare-COM enhancement
assign deskew_see_idl_os =   /*chk_com[1] &*/ enuf(chk_idl[4:2])
                           | /*chk_com[2] &*/ enuf(chk_idl[5:3])
                           | /*chk_com[3] &*/ enuf(chk_idl[6:4])
                           | /*chk_com[4] &*/ enuf(chk_idl[7:5]);

// function to determine when enough IDL symbols are detected.
function automatic enuf;
input [2:0] chk;
begin
// Spec requires 2 of 3 valid IDL characters. RocketIO needs weaker checking
     enuf =  chk[0] & chk[1]
           | chk[1] & chk[2]
           | chk[0] & chk[2];
end
endfunction // enuf

//logic below for deasserting deskew_rxdata_dv immediately when detecting an EIOS
always @(posedge core_clk or negedge core_rst_n) begin : latched_deskew_see_idl_os_PROC
    if (~core_rst_n)
        latched_deskew_see_idl_os <= #TP 1'h0;
    //if deskew_see_idl_os, no deskew_enable, no push to deskew buffer
    //then buffer will be empty, then !int_rxvalid (!deskew_rxdata_dv_i)
    else if (deskew_bypass ? !deskew_enable : !int_rxvalid)
        //if deskew_bypass, when deskew_enable=0, reset latched_deskew_see_idl_os
        latched_deskew_see_idl_os <= #TP 1'b0;
    else if (deskew_see_idl_os)
        latched_deskew_see_idl_os <= #TP 1'b1;
end

assign int_deskew_see_idl_os = latched_deskew_see_idl_os /* | deskew_see_idl_os */;

always @(posedge core_clk or negedge core_rst_n) begin : slv_do_deskew_d_PROC
    if (~core_rst_n)
        slv_do_deskew_d <= #TP 1'b0;
    else
        slv_do_deskew_d <= #TP slv_do_deskew;
end // slv_do_deskew_d_PROC

// artificially make a SKP symbol to reset pkt_finder after deskew_enable deassertion for sris at gen1/2 rate
// this is safe because slv_do_deskew=0 makes deskew_rxdat_dv = 0. Here is manually making a pulse with deskew_rxdat_dv = 1 on all lanes with skp symbol at the same cycle
// do not need extra_k_sris_flag pulse because the core has deskew_rxdata_flush_gen12 signal to pkt_finder to indicate the deskew ends.
assign extra_k_sris_flag = 0; //~slv_do_deskew & slv_do_deskew_d & (current_data_rate == `GEN1_RATE || current_data_rate == `GEN2_RATE) & cfg_ts2_lid_deskew & ~deskew_bypass;

   always @(posedge core_clk or negedge core_rst_n)
     if (~core_rst_n)
        prev_com_reg <= #TP 1'b0;
     else if (~slv_do_deskew)
        prev_com_reg <= #TP 1'b0;
     else
        prev_com_reg <= #TP ~int_rxdata_dv ? prev_com_reg    : // if the rxdata is not valid, then keep the previous value
                              active_nb[1] ? rxdata_comma[1] : // 2s
                                             rxdata_comma[0] ; // 1s

   always @(posedge core_clk or negedge core_rst_n)
     if (~core_rst_n)
        prev_skp_reg <= #TP 1'b0;
     else if (~slv_do_deskew)
        prev_skp_reg <= #TP 1'b0;
     else
        prev_skp_reg <= #TP ~int_rxdata_dv ? prev_skp_reg   :  // if the rxdata is not valid, then keep the previous value
                              active_nb[1] ? rxdata_skip[1] :  // 2s
                                             rxdata_skip[0] ;  // 1s

   always @(posedge core_clk or negedge core_rst_n) begin : prev_skprm_reg_PROC
     if (~core_rst_n)
        prev_skprm_reg <= #TP 1'b0;
     else if (~slv_do_deskew)
        prev_skprm_reg <= #TP 1'b0;
     else
        prev_skprm_reg <= #TP ~int_rxdata_dv ? prev_skprm_reg   :  // if the rxdata is not valid, then keep the previous value
                                active_nb[1] ? rxdata_skprm[1] :  // 2s
                                               rxdata_skprm[0] ;  // 1s
   end // prev_skprm_reg_PROC

   always @(posedge core_clk or negedge core_rst_n)
     if (~core_rst_n)
        prev_ts2_reg <= #TP 1'b0;
     else if (~slv_do_deskew) 
        prev_ts2_reg <= #TP 1'b0;
     else
        prev_ts2_reg <= #TP ~int_rxdata_dv ? prev_ts2_reg   :  // if the rxdata is not valid, then keep the previous value
                              active_nb[2] ? smseq_loc_ts2_rcvd[3] :  // 4s
                              active_nb[1] ? smseq_loc_ts2_rcvd[1] :  // 2s
                                             smseq_loc_ts2_rcvd[0] ;  // 1s


// Note: priority encoded
   wire [NB-1:0] load_rxvec0; // load signal for byte lane 0 (from rxdata), before byte shifting
   assign load_rxvec0 =  write_rxword[0] ? (1'b1 << 0)
                       : write_rxword[1] ? (1'b1 << 1)
                       : {NB{1'h0}};
   wire [NB-1:1] load_rxvec1; // load signal for byte lane 1 (from rxdata), before byte shifting
   assign load_rxvec1 =  (~load_rxvec0[1] & write_rxword[1]) ? (1'b1 << 0)
                       : {NB-1{1'h0}};

   always @(posedge core_clk or negedge core_rst_n)
     if (~core_rst_n)
       found_lock_reg <= #TP 1'b0;
     else if (~deskew_enable)
       found_lock_reg <= #TP 1'b0;
     else if (|found_lock_wire)
       found_lock_reg <= #TP 1'b1;

   assign found_lock = (deskew_enable & |found_lock_wire) | found_lock_reg;

// We consider the first character after a comma to be the "lock" point
// or the first idle data symbol following the last ts2/skp received if CPCIE && cfg_ts2_lid_deskew==1
   assign found_lock_wire = (smlh_in_rl0s && cfg_ts2_lid_deskew && (phy_type != `PHY_TYPE_MPCIE)) ? // Rx.L0s, detecting skp only ok because the remote only transmits one SKP following FTS in Tx.L0s state
                             (({
                               |active_nb[2:1] & (rxdata_skprm[1] ? 1'b1 : (rxdata_comma[0] & ~rxdata_skprm[0] & rxdata_skip[1])),
                               rxdata_skprm[0] ? 1'b1 : (prev_com_reg & ~prev_skprm_reg & rxdata_skip[0])
                              }) & write_rxword_unmask
                             ) // Rx.L0s
                            :
                            (~ltssm_lpbk_master && skp_lid_lock_point && cfg_ts2_lid_deskew && (phy_type != `PHY_TYPE_MPCIE)) ? // skp->idle, but not for ltssm_lpbk_master
                             (({
                               |active_nb[2:1] & ((rxdata_skip[0]) & rx_idle_data[1]),
                               ((prev_skp_reg) & rx_idle_data[0])
                              }) & write_rxword_unmask
                             ) // skp->idle
                            :
                             (({
                               |active_nb[2:1] & ((smseq_loc_ts2_rcvd[0]) & rx_idle_data[1]),
                               ((prev_ts2_reg) & rx_idle_data[0])
                               } & {NB{(phy_type != `PHY_TYPE_MPCIE) && cfg_ts2_lid_deskew}}) | // ts2/eieos->idle
                               {
                                 |active_nb[2:1] & ((rxdata_comma[0] & ~rxdata_skprm[0]) | rxdata_skprm[1]),
                               ((prev_com_reg & ~prev_skprm_reg) | rxdata_skprm[0])}
                             ) & write_rxword_unmask // next symbol to comma
                            ;  // just pull out the lock points from write_rxword_unmask
                               // Note that write_rxword_unmask also gets asserted for
                               // non-previous commas

   // write_rxword is high when this particular byte should be written into the fifos
   // NOTE: before byte shifting

wire [NB-1:0] write_lock_word;

   // if you haven't found lock yet, then only write in the bytes that are after the lock point
   assign write_lock_word =  {NB{found_lock_reg}}
                           | (~deskew_enable      ? 2'b00 :
                               found_lock_wire[0] ? 2'b11 :
                               found_lock_wire[1] ? 2'b10 : 2'b00);

   assign write_rxword = write_lock_word & write_rxword_unmask;

assign look_for_alignment = slv_do_deskew & ~deskew_overflow_i;

   // in order to support infinite deskew, we must detect a transition between receiving TS1s and TS2s
always @(posedge core_clk or negedge core_rst_n)
    if (~core_rst_n) begin
        ts_state       <= #TP 5'h0;
        ts_state[IDLE] <= #TP 1'b1;
    end else
        ts_state       <= #TP next_ts_state;

assign     next_ts_state = ns_ts_gen(ts_state, look_for_alignment, smseq_ts1_rcvd_pulse, smseq_ts2_rcvd_pulse, found_lock_wire, deskew_bypass);

function automatic [4:0] ns_ts_gen;
    input [4:0] ts_state;
    input look_for_alignment;
    input smseq_ts1_rcvd_pulse;
    input smseq_ts2_rcvd_pulse;
    input [NB-1:0] found_lock_wire;
    input deskew_bypass;
    reg [4:0] result;
    begin
        result = 5'h0;

             case (1'b1)
            ts_state[IDLE]:
                if (look_for_alignment & smseq_ts1_rcvd_pulse)
                    result[TS1_RCVD]    = 1'b1;
                else if (look_for_alignment & smseq_ts2_rcvd_pulse & deskew_bypass) // if deskew_bypass, no skew across lanes, so detecting TS2 is to enable deskew_rxdata_dv
                    result[TS2_RCVD]    = 1'b1;
                else
                    result[IDLE]        = 1'b1;
            ts_state[TS1_RCVD]:
                if (look_for_alignment & smseq_ts2_rcvd_pulse)
                    result[TS2_RCVD]    = 1'b1;
                else if (~look_for_alignment)
                    result[IDLE]    = 1'b1;
                else
                    result[TS1_RCVD]    = 1'b1;
            ts_state[TS2_RCVD]:
                if (look_for_alignment & |found_lock_wire)
                    result[SUCCESS]     = 1'b1;
                else if (look_for_alignment & smseq_ts2_rcvd_pulse)
                    result[ALIGN_ERROR] = 1'b1;
                else if (~look_for_alignment)
                    result[IDLE]    = 1'b1;
                else
                    result[TS2_RCVD]    = 1'b1;
            ts_state[ALIGN_ERROR]:
                if (~look_for_alignment)
                    result[IDLE]        = 1'b1;
                else
                    result[ALIGN_ERROR] = 1'b1;
            default: // ts_state[SUCCESS]
                if (~look_for_alignment)
                    result[IDLE]        = 1'b1;
                else
                    result[SUCCESS] = 1'b1;
        endcase // case(1'b1)
        ns_ts_gen = result;
    end
endfunction

assign ts_do_deskew = next_ts_state[TS2_RCVD] | ts_state[TS2_RCVD] | ts_state[SUCCESS];

always @(posedge core_clk or negedge core_rst_n)
  if (~core_rst_n)
      skp_do_deskew_reg <= #TP 1'b0;
  else if (~look_for_alignment)
      skp_do_deskew_reg <= #TP 1'b0;
  else if (skp_lock_point)
      skp_do_deskew_reg <= #TP 1'b1;

always @(posedge core_clk or negedge core_rst_n)
    if (~core_rst_n)      
        skp_do_deskew_r <= #TP 1'b0;
    else
        skp_do_deskew_r <= #TP skp_do_deskew;

// use ts2/skp -> Logic Idle Data Transition to do deskew
always @( * ) begin : i_rxdata_PROC // max 4 bytes for Gen1/2
    i_rxdata = 32'hFFFFFFFF;

    i_rxdata = {
               16'hFFFF,

               rxdata[15:8],

               rxdata[7:0]
               };
end // i_rxdata_PROC

always @( * ) begin : i_rxdatak_PROC // max 4 bytes for Gen1/2
    i_rxdatak = 4'hF;

    i_rxdatak = {
               2'b11,

               rxdatak_i[1],

               rxdatak_i[0]
               };
end // i_rxdatak_PROC

always @( * ) begin : i_rxerror_PROC // max 4 bytes for Gen1/2
    i_rxerror = 4'hF;

    i_rxerror = {
               2'b11,

               rxerror[1],

               rxerror[0]
               };
end // i_rxerror_PROC

// rxvalid = 1 & rxdatavalid = 1, no k-char, no Rx Error, rxdata[8 bits] must be 8'h0
assign rx_idle_data = {4{rxdata_dv}} & ~i_rxdatak & ~i_rxerror & {i_rxdata[31:24]==8'h0, i_rxdata[23:16]==8'h0, i_rxdata[15:8]==8'h0, i_rxdata[7:0]==8'h0};
assign rx_data_char = {4{rxdata_dv}} & ~i_rxdatak & ~i_rxerror;

always @( posedge core_clk or negedge core_rst_n) begin : dly_loc_ts2_rcvd_PROC
    if ( ~core_rst_n ) begin
        dly_loc_ts2_rcvd <= #TP 0;
        dly_in_skp       <= #TP 0;
    end else if ( ~rxaligned ) begin // if rxvalid, no ts2 or skp rcvd
        dly_loc_ts2_rcvd <= #TP 0;
        dly_in_skp       <= #TP 0;
    end else if ( cfg_elastic_buffer_mode && ~rxdata_dv ) begin // if rxdatavalid=0 & cfg_elastic_buffer_mode (empty), keep previous value
        dly_loc_ts2_rcvd <= #TP dly_loc_ts2_rcvd;
        dly_in_skp       <= #TP dly_in_skp;
    end else begin
        dly_loc_ts2_rcvd <= #TP smseq_loc_ts2_rcvd;
        dly_in_skp       <= #TP smseq_in_skp;
    end
end // dly_loc_ts2_rcvd_PROC

always @( * ) begin : ts2_lid_lock_point_PROC
    ts2_lid_lock_point = 0;

    if ( active_nb == 1 ) begin // 1s
        ts2_lid_lock_point = dly_loc_ts2_rcvd[0] & rx_idle_data[0]; // previous cycle byte 0 is ts2 rcvd AND current cycle byte 0 is idle data
    end else if ( active_nb == 2 ) begin
        // current cycle byte 0 is ts2 rcvd AND current cycle byte 1 is idle data
        // previous cycle byte 1 is ts2 rcvd AND current cycle byte 0 is idle data
        ts2_lid_lock_point = (smseq_loc_ts2_rcvd[0] & rx_idle_data[1]) | (dly_loc_ts2_rcvd[1] & rx_idle_data[0]);
    end else if ( active_nb == 4 ) begin
        // current cycle byte 0 is ts2 rcvd AND current cycle byte 1 is idle data
        // current cycle byte 1 is ts2 rcvd AND current cycle byte 2 is idle data
        // current cycle byte 2 is ts2 rcvd AND current cycle byte 3 is idle data
        // previous cycle byte 3 is ts2 rcvd AND current cycle byte 0 is idle data
        ts2_lid_lock_point = (smseq_loc_ts2_rcvd[0] & rx_idle_data[1]) | (smseq_loc_ts2_rcvd[1] & rx_idle_data[2]) | (smseq_loc_ts2_rcvd[2] & rx_idle_data[3]) | (dly_loc_ts2_rcvd[3] & rx_idle_data[0]);
    end
end // ts2_lid_lock_point_PROC


// if a wrong idle data occurs between SKP Symbols in a SKP OS, the deskew logic will have deskew_skp_alignment_err. So no worry about this
always @( * ) begin : skp_lid_lock_point_PROC
    skp_lid_lock_point = 0;

    if ( active_nb == 1 ) begin // 1s
        skp_lid_lock_point = dly_in_skp[0] & rx_idle_data[0]; // previous cycle byte 0 is skp rcvd AND current cycle byte 0 is idle data
    end else if ( active_nb == 2 ) begin
        // current cycle byte 0 is skp rcvd AND current cycle byte 1 is idle data
        // previous cycle byte 1 is skp rcvd AND current cycle byte 0 is idle data
        skp_lid_lock_point = (smseq_in_skp[0] & rx_idle_data[1]) | (dly_in_skp[1] & rx_idle_data[0]);
    end else if ( active_nb == 4 ) begin
        // current cycle byte 0 is skp rcvd AND current cycle byte 1 is idle data
        // current cycle byte 1 is skp rcvd AND current cycle byte 2 is idle data
        // current cycle byte 2 is skp rcvd AND current cycle byte 3 is idle data
        // previous cycle byte 3 is skp rcvd AND current cycle byte 0 is idle data
        skp_lid_lock_point = (smseq_in_skp[0] & rx_idle_data[1]) | (smseq_in_skp[1] & rx_idle_data[2]) | (smseq_in_skp[2] & rx_idle_data[3]) | (dly_in_skp[3] & rx_idle_data[0]);
    end
end // skp_lid_lock_point_PROC

// keep the lock point until ~look_for_alignment
always @(posedge core_clk or negedge core_rst_n) begin : latched_ts2_lid_lock_point_PROC
  if (~core_rst_n)    
      latched_ts2_lid_lock_point <= #TP 1'b0;
  else if ( ~look_for_alignment )
      latched_ts2_lid_lock_point <= #TP 1'b0;   
  else if ( ts2_lid_lock_point )
      latched_ts2_lid_lock_point <= #TP 1'b1;   
end // latched_ts2_lid_lock_point_PROC


// keep the lock point until ~look_for_alignment
always @(posedge core_clk or negedge core_rst_n) begin : latched_skp_lid_lock_point_PROC
  if (~core_rst_n)    
      latched_skp_lid_lock_point <= #TP 1'b0;
  else if ( ~look_for_alignment )
      latched_skp_lid_lock_point <= #TP 1'b0;
  else if ( skp_lid_lock_point )
      latched_skp_lid_lock_point <= #TP 1'b1;
end // latched_skp_lid_lock_point_PROC

assign fts_skp_lock_point = smseq_fts_skp_do_deskew;

// keep the lock point until ~look_for_alignment
always @(posedge core_clk or negedge core_rst_n) begin : latched_fts_skp_lock_point_PROC
  if (~core_rst_n)    
      latched_fts_skp_lock_point <= #TP 1'b0;
  else if ( ~look_for_alignment )
      latched_fts_skp_lock_point <= #TP 1'b0;
  else if ( fts_skp_lock_point )
      latched_fts_skp_lock_point <= #TP 1'b1;
end // latched_fts_skp_lock_point_PROC

assign skp_do_deskew = skp_lock_point | skp_do_deskew_reg;
assign ts2_lid_do_deskew = ts2_lid_lock_point  | latched_ts2_lid_lock_point;
assign skp_lid_do_deskew = skp_lid_lock_point  | latched_skp_lid_lock_point;
assign fts_skp_do_deskew = fts_skp_lock_point  | latched_fts_skp_lock_point;

// loopback master may not send logical idle data following SKP in Loopback.Active. deskew cannot complete.
// rdlh_dlcntrl_state from Layer 2 cannot get `S_DL_ACTIVE. So we have to use skp_do_deskew mechanism regardless of cfg_ts2_lid_deskew=1 or 0 for loopback master (implementation specific).
// if ts1->ts2 does not occur in Recovery.RcvrCfg because of bit lock issue, use ts2->Idle_Data.
// at least one side of the link receives TS1s in Recovery.RcvrLock and moves to Recovery.RcvrCfg. This side can use TS1->TS2. The other side only receives TS2, so TS2->Logic_Idle_Data
// if remote sends last TS2 and then a SKP OS and then Idle Data, then the local core has to detect skp -> Idle_Data
// for Rx.L0s, we need FTS -> SKP
// at least one side should have ts1->ts2 and deskew_complete and then to Rcvry.Idle sending Idle_Data. So the other side can have ts2->Idle deskew when NO skp_do_deskew.
// MPCIE   cfg_ts2_lid_deskew
//  0             0               skp_do_deskew
//  0             1               ts2_lid_do_deskew || skp_lid_do_deskew || fts_skp_do_deskew `ifdef CX_GEN2_SPEED || eies_lid_do_deskew `endif
//  1             0               skp_do_deskew
//  1             1               skp_do_deskew
assign deskew_enable =
                       look_for_alignment
                      & ( (ts_do_deskew                                       && ~cfg_ts2_lid_deskew) |       // because of a TS1->TS2 transition
                          (ts2_lid_do_deskew  && (phy_type != `PHY_TYPE_MPCIE && cfg_ts2_lid_deskew)) |       // because of ts2 -> Idle_Data transition
                          (skp_lid_do_deskew  && (phy_type != `PHY_TYPE_MPCIE && cfg_ts2_lid_deskew)) |       // because of skp -> Idle_Data transition
                          (skp_do_deskew      && (phy_type != `PHY_TYPE_MPCIE && cfg_ts2_lid_deskew && ltssm_lpbk_master)) |       // because of skp detection, for loopback master only
                          (fts_skp_do_deskew  && (phy_type != `PHY_TYPE_MPCIE && cfg_ts2_lid_deskew)) |       // because of fts -> skp transition for RxL0s
                          (skp_do_deskew      && (phy_type == `PHY_TYPE_MPCIE || ~cfg_ts2_lid_deskew))        // because of SKP detection
                        );

always @(posedge core_clk or negedge core_rst_n) begin : deskew_enable_d_PROC
    if ( ~core_rst_n )
        deskew_enable_d <= #TP 0;
    else
        deskew_enable_d <= #TP deskew_enable;
end // deskew_enable_d_PROC

assign deskew_enable_rising_edge = deskew_enable & ~deskew_enable_d;

always @( posedge core_clk or negedge core_rst_n ) begin : deskew_ds_g12_PROC
    if ( ~core_rst_n )
        deskew_ds_g12 <= #TP 0;
    // look_for_alignment = slv_do_deskew & ~deskew_overflow_i. slv_do_deskew = (~deskew_alignmenterror_i & smlh_do_deskew & ~any_deskew_see_idl_os)
    else if ( ~look_for_alignment || current_data_rate >= `GEN3_RATE || rpipe_eios_eieos_det )
        deskew_ds_g12 <= #TP 0;
    //after ts2/skp/eieos->Idle or fts->skp or loopback master in Loopback.Active, the port starts receiving data stream
    else if ( deskew_enable && (ts2_lid_do_deskew || skp_lid_do_deskew || (ltssm_lpbk_master && smlh_ltssm_state == `S_LPBK_ACTIVE) || fts_skp_do_deskew) )
        deskew_ds_g12 <= #TP 1;
end // deskew_ds_g12_PROC

   // next_load points to the first fifo to be loaded with data
   // for 2s and 4s
   reg [NB-1:0] next_load;
always @(posedge core_clk or negedge core_rst_n)
  if (~core_rst_n)
    next_load <= #TP 1;
  else if (~deskew_enable || (active_nb!=active_nb_d))
    next_load <= #TP 1; // reset, so the first byte goes to fifo0
  else if (load1)
    next_load <= #TP active_nb[1] ? {next_load[0], next_load[1]}  // if we're in 2s mode then rotate across all fifos
                                  : 1;  // if in 1s mode then keep pointing at fifo 1, since only fifo1 is active

assign load1 =  shift_in_load[0]
              & ~shift_in_load[1]
              ;


// Instantiate the FIFOs
// DWC_pcie_ctl_bcm65 = synchronous FIFO
parameter WIDTH      = (`CX_GEN3_MODE!=2 && `CX_NB_GEN3==1) ? 12 : 10;  // RANGE 1 TO 256
parameter BWK        = (`CX_GEN3_MODE!=2 && `CX_NB_GEN3==1) ? 2  : 1;   // RANGE 1 TO 2 , byte width of datak for sync_header
parameter DEPTH      = `CX_DESKEW_DEPTH;            // need depth of 5 in order to support 2s
parameter AF_LEVEL   = DEPTH - `CX_AF_DESKEW_DEPTH; // AF output is used as full when in 4s mode
parameter ADDR_WIDTH = `CX_DESKEW_ADDR_WIDTH;       // RANGE 1 TO 8
parameter AE_LEVEL   = 1;                           // RANGE 0 TO 255
parameter ERR_MODE   = 0;                           // RANGE 0 TO 2
parameter RST_MODE   = 0;                           // RANGE 0 TO 1

// BCM65 transport delay parameters
localparam integer REG_DELAY_DENOM = 1000;
localparam integer REG_DELAY_TIME  = `TP * REG_DELAY_DENOM;
wire [7:0] active_fifo;

   assign active_fifo = (
                         active_nb[1] ? 8'h03 : // 2s
                                        8'h01
                         );

always @( * ) begin : skp_PROC
    integer j;
    
    bit_kchar = 0;

    for (j=0; j<NB; j=j+1) begin
        if (active_fifo[j] == 1'b1) begin
            bit_kchar[j+:1] = 1'b1;
        end
    end  
end // skp_PROC

assign    push_req_n = {
                        ~(shift_load[1] & active_fifo[1]),
                        ~(shift_load[0] & active_fifo[0])
                        };

wire unload_g12 = unload; //the unload from rmlh_deskew.v is the one for Gen_1/2 rate

//for gen3 rate, deskew is done by per-lane-version, i.e., pop-up !empty buffers per lane until meeting SDS.
//when all lanes rcvd SDS, then move to DATA STREAM. Likewise for SKP, all buffers not empty, move to Data Stream
wire unload_mux =
                  unload_g12;

//for bare COM for Gen1/2 rate or bare SKP_END 4 symbols for Gen3/4 rate, need to replace COM or SKP_END with SKP symbol (8'h1C) or 8'hAA
assign shift_rxdata_in =                            ({
                           |active_nb[2:1] & shift_rxskprm[1] ? 8'h1C : shift_comlock[1] ? 8'h00 : shift_rxdata[15:8],
                                             shift_rxskprm[0] ? 8'h1C : shift_comlock[0] ? 8'h00 : shift_rxdata[7:0]
                            });

assign shift_rxdatak_in =                            ({
                           |active_nb[2:1] & (shift_rxskprm[1] | shift_comlock[1]) ? 1'b1 : shift_rxdatak[1],
                                             (shift_rxskprm[0] | shift_comlock[0]) ? 1'b1 : shift_rxdatak[0]
                            });

genvar i;
generate
for (i=0; i<NB; i = i+1) begin : gen_fifo
    DWC_pcie_ctl_bcmmod65_init_td_mod
     #(
     .WIDTH           (WIDTH          )
    ,.DEPTH           (DEPTH          )
    ,.AE_LEVEL        (AE_LEVEL       )
    ,.AF_LEVEL        (AF_LEVEL       )
    ,.ERR_MODE        (ERR_MODE       )
    ,.RST_MODE        (RST_MODE       )
    ,.ADDR_WIDTH      (ADDR_WIDTH     )
    ,.REG_DELAY_TIME  (REG_DELAY_TIME )
    ,.REG_DELAY_DENOM (REG_DELAY_DENOM)
   ) word_fifo (
    .clk          (core_clk),
    .rst_n        (core_rst_n),
    .init_n       (deskew_enable),
    .push_req_n   (push_req_n[i]),
    .pop_req_n    (~(unload_mux & active_fifo[i]) ),   // unloads happen across all active fifos at the same time
    .diag_n       (1'b1),
    .data_in      ({shift_rxerror[BWK*i +: BWK], shift_rxdatak_in[BWK*i +: BWK], shift_rxdata_in[(8*(i+1))-1:(8*i)]}),

    .empty        (empty_fifo[i]),
    .almost_empty (),
    .half_full    (),
    .almost_full  (almost_full[i]),
    .full         (full[i]),
    .error        (),
    .data_out     ({deskew_rxerror_fifo[BWK*i +: BWK], deskew_rxdatak_fifo[BWK*i +: BWK], deskew_rxdata_fifo[(8*(i+1))-1:(8*i)]})
);
end
endgenerate

// deskew_bypass==1 only for Gen1/2 rate, mux between FIFO read and raw input
assign deskew_rxerror_i = deskew_bypass ? rxerror                                      : deskew_rxerror_fifo; // NB
assign deskew_rxdatak_i = deskew_bypass ? rxdatak                                      : deskew_rxdatak_fifo;
assign deskew_rxdata_i  = deskew_bypass ? rxdata                                       : deskew_rxdata_fifo;
// ~load_g3 if for drift buffer only because deskew_bypass = 1 only for >= GEN3_RATE && drift_buffer
// empty if bypass FIFO and nominal empty mode and RxDataValid=0 or RxValid=0
assign empty            = deskew_bypass ? {NB{((~rxdata_dv & cfg_elastic_buffer_mode))}} : empty_fifo;



assign shift_load    = shift_bit(shift_in_load,    next_load, active_nb);
assign shift_rxerror = shift_bit(shift_in_rxerror, next_load, active_nb);
assign shift_rxdatak = shift_bit(shift_in_rxdatak, next_load, active_nb);
assign shift_rxskprm = shift_bit(shift_in_rxskprm, next_load, active_nb);
assign shift_comlock = shift_bit(shift_in_comlock, next_load, active_nb);
assign shift_rxdata  = shift_word(shift_in_rxdata, next_load, active_nb);


assign shift_in_load = {
                   |load_rxvec1,
                   |load_rxvec0};

assign shift_in_rxerror = {

                           // bit 1, needed for NB_2 and NB_4
                             load_rxvec1[1] ? rxerror[1] : 1'b0
                           ,

                           // bit 0, needed for all NB
                             load_rxvec0[0] ? rxerror[0] : 1'b0
                           | load_rxvec0[1] ? rxerror[1] : 1'b0
                           };

assign shift_in_rxdatak = {

                           // bit 1, needed for NB_2 and NB_4
                             load_rxvec1[1] ? rxdatak[1] : 1'b0
                           ,

                           // bit 0, needed for all NB
                             load_rxvec0[0] ? rxdatak[0] : 1'b0
                           | load_rxvec0[1] ? rxdatak[1] : 1'b0
                           };

assign shift_in_rxskprm = {

                           // bit 1, needed for NB_2 and NB_4
                             load_rxvec1[1] ? rxdata_skprm[1] : 1'b0
                           ,

                           // bit 0, needed for all NB
                             load_rxvec0[0] ? rxdata_skprm[0] : 1'b0
                           | load_rxvec0[1] ? rxdata_skprm[1] : 1'b0
                           };

assign shift_in_comlock = {

                           // bit 1, needed for NB_2 and NB_4
                             load_rxvec1[1] ? com_lock_point[1] : 1'b0
                           ,

                           // bit 0, needed for all NB
                             load_rxvec0[0] ? com_lock_point[0] : 1'b0
                           | load_rxvec0[1] ? com_lock_point[1] : 1'b0
                           };

assign shift_in_rxdata = {

                           // bit 1, needed for NB_2 and NB_4
                             (load_rxvec1[1] ? rxdata[15:8] : 8'b0)
                           ,

                           // bit 0, needed for all NB
                             (load_rxvec0[0] ? rxdata[7:0] : 8'b0)
                           | (load_rxvec0[1] ? rxdata[15:8] : 8'b0)
                           };

   function automatic [NB-1:0] shift_bit;
   input [NB-1:0] data;
   input [NB-1:0] shift_data;
   input [AW-1:0] active_nb;
   begin
                    // 1s mode
      shift_bit = (active_nb[0]) ? {1'b0, data[0]}
                    // 2s mode
                                 : shift_data[0] ? data[1:0] : {data[0], data[1]};
   end
   endfunction

   function automatic [NB*8-1:0] shift_word;
   input [NB*8-1:0] data;
   input [NB-1:0]   shift_data;
   input [AW-1:0]   active_nb;
   begin
                    // 1s mode
      shift_word = (active_nb[0]) ? {8'h0, data[7:0]}
                    // 2s mode
                                 : shift_data[0] ? data[15:0] : {data[7:0], data[15:8]};
   end
   endfunction

`ifndef SYNTHESIS
//VCS coverage off
   // signals for debug
assign shift_skip_in     = {

                      (shift_rxdatak[1] & (shift_rxdata[15:8] == `SKIP_8B)),

                      (shift_rxdatak[0] & (shift_rxdata[7:0] == `SKIP_8B))};
//VCS coverage on
`endif // SYNTHESIS



endmodule
